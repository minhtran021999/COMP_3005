##### Course Introductions #####

'''
office hrs
TA
communication
expectations for class prep - complete asynchronous day before live session
submitting homework & due dates
'''

##### Learning Goals #####

# Create and save a simple python program file and execute it using a shell or IDE
# Document code for interpretation and reproducibility, use multiline strings
# Distinguish between a Python variable, expression, and statement
# Use proper naming syntax for variable names (camel-case, snake-case)
# Manipulate numerical variable & string types and use casting to convert - between types
# Build expressions using arithmetic, assignment, comparison, and logical - operators with appropriate precedence

##### HOMEWORK OVERVIEW #####

# Question 6: IF/ELSE - Conditional

'''if something:
    do something
else:
    do something else'''

# Example 1. Note: == compares object value not memory (is compares identity)

tom = 'a cat'
 
if type(tom) == str: 
    print('The reference name tom points to a value in memory that is a string type')

else:
    print('I have no idea who tom is!!')
 
# Example 2 

tom = 'a cat'

if type(tom) == str and tom.startswith('t'):
    print('The reference name tom points to a value in memory that is a string type')
else:
    print('I have no idea who tom is!!')

# Thought question: what do. you think this will print? 
# A note: .startswith() is a string method. We'll cover that in a later module.


##### Terminal Commands and Python #####

# pwd - checks the current working directory

# ls (mac) or dir (Windows) - lists subdirectories & files in working directory

# mkdir "your folder name" - create a folder

# cd "your folder name" - change directory to the project folder you created

# nano "your file name.py" - launches the nano text editor. You can set up other editors as your default

# print("Just a demo of functionality") - write your python code

# In Nano, select Ctrl-X > Yes, to name & save your .py file

# cat "your file name" - see what your file contains. in windows replace 'cat' with 'type''

# python3 "your file name" - execute your python code. In windows: python "your file name"

# echo 'print("This is new content.")' >> "your file name"  # adds new content to file without overwriting

# rm "your file name" - deletes your file. In windows replace 'rm' with 'del' 

# cd .. - move up a directory to your project folder

# rmdir "your folder name" - deletes the project folder


##### Text Editors #####

# Sublime Text or TextMate for Mac
# NotePad ++ for Windows


##### COMMENTING and CONTINUATION PYTHON #####

# ---------- Example 1. Single Line Comments ---------------

# The hash starts a single line comment

# ---------- Example 2. Multi Line Comments ---------------

'''multiline
comments'''

# ---------- Example 3. Line Conintuation --> \ ---------------

a = 'Hello, \ 
do you have a parakeet named Tom?'

print(a)


###### NAMING RULES AND CONVENTIONS #####

'''
1. Identifiers & Rules:

Are case sensitive
Can only start with _ or a letter, followed by any number of underscores, letters, or digits (digits represent humbers in a counting system)
Cannot be reserved words, e.g., False, None, not, if

2. Conventions:

packages: lower-case and no underscores
modules: lowercase, can have underscores
classes: camelcase
functions: lowercase, snakecase
variables: lowercase, words separaed by underscores
constants: all uppercase, words separated by underscores

3. Recommentations

Use names that are descriptive, avoid x, y etc.
Dont use names that represent constant variable types - e.g., pi

4. Related Vocabulary

Literals: refer to variables with fixed values

z = x + y (names or references)
x = 4 + 5 (literals/operands (inputs to + operator))

A valid Python name, also known as an identifier, can only contain alphanumeric 
characters (A-Z, a-z, 0-9) and the underscore character (_). An additional rule 
is that a name cannot begin with a number.
'''

# ---------- Example 4. Rules ---------------

_J = 'James'   # this will run, can start with an underscore followed by a letter
1R = 'Sam' # this will not run", cant start with a number 
True = 16  # this will not run (reserved words): False, None, not if
!var1 = 4 # wont run, cant include a symbol
var1! = 4  # wont run
var1 = 4 # will run

# ---------- Example 4. Conventions ---------------

new_name = 'Elliot' # snakecase (variables, functions)
SPEEDOFLIGHT = 299,792,458 # constants (m/sec)
newName = 'John' # camelcase (classes)

# Examples - # Can you explain the difference between a statement and an expression?

a = 5
print(f'I am the reference name "a", and I\'m the variable a: {a}') # see section on print formatting

var_sum = a + 4 # this is an assignment 'statement', it include the 'expression' a + 4
print(f'The sum generated by adding a (referene that point to a object with value = 5) \
    to 4 (a literal): {var_sum}')

print(type(var_sum))


# The output of a function can be assigned to a name (functions are objects)

def variable_assignment_example(my_variable: int = None):
    out = my_variable + 5
    return out

var_func = variable_assignment_example(6)
print(f'Here is the return value from our function: {var_func}')


##### PRINT FORMATTING - FORMAT AND F-STRINGS #####

# ---------- Example 5. Format ---------------

my_variable = 1745.66666

# 1. Start with format() method

print('The value of "my_variable" is: {}'. format(my_variable))

print('The value of "my_variable" is {:.2f}'.format(my_variable))  # decimal placement

print('The value of "my_variable" is {:.2g}'.format(my_variable))  # significant digits


# g stands for general format. It selects between fixed point and scientific notation. Controls the total number of digits
# f always selects fixed point. Controls digits after the decimal point

# ---------- Example 6. F-String ---------------


# 2. Compare with fstring - formated string literal

print(f'The value of "my_variable" is: {my_variable}.')

print(f'The value of "my_variable" is: {my_variable:.2f}.') # specify signif digits

# ---------- Example 7. Input() ---------------

# 3. User Input()

user_name = input('Please enter your full name: ')

print(f'Your name is {user_name} correct?')

entry_value = input("Please enter a whole number between 1 and 10 ") # note space at end

print(entry_value)

integer_value = 100

print(entry value + integer_value)

# ---------- Example 8. Escape Characters & Line Continuation ---------------

# 4. Escape Characters - tell Python to treat next character as a literal not a special cmd

# print("This is a backslash: \.")# escape not requited in pytnon 3.6 and later

a = 5

print(f'I am the character "a", and I\'m the variable a: {a}')

# 5. Line Continuation


line_continued_message = "This is a message that is split " \
                       "across multiple lines to improve readability. " \
                       "It contains a literal backslash: \\"

print(line_continued_message)


# ---------- Example 9. END() ---------------

# 6. End = " ", replaces print default \n with a space

for i in range(5):
    print(".")

for i in range(5):
    print(".", end = " ")


# Do you understand why the following print statements produce the results they do?

print(True)
print('True')
print(true)
print('true') 


##### OBJECTS - EVERYTHING IN PYTHON IS AN OBJECT #####

''' 
Every value, data structure, function, class, and module is represented as an object with:

1. Identity
2. Type
3. Value
4. Attributes and methods

Implications

1. You can assign anything to a name
2. You can pass anything as arguments
3. Everything has attributes/methods

'''

# ----------Example 10. Data as an object---------------

name = 7 # change this to a string and make comparisons with type, id, dir

print(name) # value or data
print(type(name)) # type
print(id(name)) # identity

pprint.pprint(dir(name)) # directory listing

print(name.upper()) # behavior for regular method -> fxn that belongs to an object
print(name.__len__()) # behavior for built_in method -> fxn that belongs to the type 
print(len(name))



##### PYTHON PRIMITIVE TYPES - IMMUTABLE #####

'''

1. Numeric
    1. Integer (whole number)
    2. Float (decimals)
    3. Complex (real and imaginary parts, z = 3 + 4j: 3 is real, 4 is imaginary)

2. Text - string

3. Boolean - True or False values

4. None - represents absence of a value

# All the primitive types

number = 42          # int
pi = 3.14           # float
name = "Python"     # str
is_fun = True       # bool
nothing = None      # NoneType

'''

# Unlike some programming languages, we dont need to specify type, Python infers it.

# ----------Example 11. Inferring Type ---------------

print(type(5))

print(type('string'))

print(type(True))

print(True + 1) # booleans are a subtype of int



print("hello".upper()) # upper() dot method for string objects works implicitly

print((42).__add__(5)) # __add__ builtin method works implicitly for int types 

dir(int) # directory method -> reveals builtin and standard methods. 

# Function example 

def process(obj):
    return type(obj).__name__

print(process(42)) # anything goes argument

# Builtin methods are part of the core language anc can be called by name. e.g. len(), print()
# Dot methods are bound to a specific object. Access them with a . after the object name


# ---------- Example 12. Type Setting ---------------

name: str = 'Alice' # type hints

print(name)

# ---------- Example 13. Type Binding (Value Assignment) ---------------

name = 'Alice' # assigns str value Alice to name
name = 42

# ---------- Example 14. TYPE CASTING - explicit type changes ---------------


a = "23"
print(int(a))

b = "b" # source code

print(int(b)) # generates invalid literal error

# Below: a bit more to embellish with

var_int = 123

print(
    f'To start, my type is: {type(var_int)}\n'
    f'but now... {type(str(var_int))}\n'
    f'and wait! Now I\'m {type(float(var_int))}'
)

print(type(var_int))


# ---------- Example 15. TYPE CONVERSION -explicit ---------------


age = int("25")
print(age)

# ---------- Example 16. TYPE CONVERSION - implicit ---------------

# Implicit conversion: -> low to high types. hierarchy is int -> float -> complex. limited to numeric types

a = 5
b = 2.5

result = a + b
print(result)

print("9" + 10) # type error, unsupported operand -> explicit casting required

print("9" + "10") # concatenation


##### COLLECTION TYPES, SEQUENCE TYPES, BUILT_IN TYPES #####  ---> Can skip this for now

'''
Collection:
    1. list - ordered, mutable
    2. tuple - ordered, immutable
    3. dict - key:value pairs
    4. set - unordered, unique items
    5. frozenset - immutable version of frozenset

Sequence:

    1. range - sequence of numbers
    2. bytes - sequence of bytes
    3. bytearray - mutable sequence of bytes

Built-in Types:

    1. function - function objects
    2. type - type of types
    3. module - imported modules
    4. file - file objects
'''


##### OBJECTS AND PYTHON MEMORY MODEL #####

'''
Names store references to values in memory

In Python, you're creating names that refer to objects, not traditional variables that contain values.

'''

#### Name (variable) assignment

import sys

int_name = 10

id(int_name) # the value returned by id() is the memory address (obj location in computers RAM)

memory_size = sys.getsizeof(int_name) 

print(memory_size) # bytes of memory: a collection of 8 bits (0, 1 values); a byte can represent 2^8 different values from 00000000 to 11111111

# NOTE:  int objects also include header info (reference counts) and pointer info (for larger values), thus small ints require more memory thatn we think!

# Augmented assignment

int_name += 2

print(int_name)


#### STRING AND NUMERICAL VALUE STORAGE IN MEMORY #####


'''
1. String data are stored in unicode form -> byte form -> machine code (binary) when compiled 

2. Numerical data are stored in binary form at the hardware level

# All computer memory is binary (0s and 1s)
x = 42
# In memory: 00101010 (8-bit representation)
# Or: 00000000000000000000000000101010 (32-bit)

y = 3.14
# In memory: 64 bits following IEEE 754 format
# 0100000000001001001000011111101101010100010001000010110100011000

'''


# ---------- Example 17. STR CHARACTER STORAGE ---------------

print(ord('b')) # prints 98 - unicode representation for 'b', ascii range is 0-127, so unicode and ascii same for 'b'

print(bin(98)[2:]) # bin = binary. [2:] - example of slicing, we will cover this when we introduce lists



# ---------- Example 18. INT STORAGE ---------------

# ints are stored binary as variable-length arrays of digits -> increase x to exponents, also try neg numbers

x = 0
binary = bin(x)[2:]

print(binary)
print(len(binary))


# ---------- Example 19. FLOAT STORAGE ---------------

# floats are stored as 64 bits following IEEE 754

import struct # packs data types into binary data and visa versa

def show_float_binary(fl):
    # Get the actual 64 binary bits
    packed = struct.pack('d', fl)  # Convert to 8 bytes
    bits = struct.unpack('Q', packed)[0]  # Read as 64-bit integer
    binary = format(bits, '064b')

    print(binary)

show_float_binary(12.7)


# ---------- Example 20. IMMUTABLE TYPES AND ALIASING ---------------

x = 67
print(id(x))

x = 3 
print(id(x)) # ints are immutable, and new object in memory has been created

y = x  # aliasing -> y and x point to the same object in memory
print(id(y), y)

y = 'colorado' # this is a new location in memory

print(x) # what will this print and why?

# variable reassignment doesnt affect other variables

x = 1
y = x + 2 
x = 7

# what does y equal?


# ---------- Example 21. OBJECT IDENTITY AND EQUALITY ---------------


# Object identity - represents whether two vars refer to the same object in memory; is operator tests for identity

# Value equality -  determines whether two vars contain the same data; == operator tests for equality

# Small integers (-5 to 256) are pre-allocated and cached -> multiple vars assigned the same small int value will reference the same object in memory. 

# Similarly, string interning may cause identical string literals to share memory locations. String interning is Python's way of saving memory by storing only one copy of identical strings and having all variables point to that same copy in memory.



x = 7  # cached values -5 to 256
y = 7

print(x == y) # value equality

print(x is y) # object identity

x = 1000
y = 1000

print(x == y) # value equality

print(x is y) # object identity

str1 = "hello"
str2 = "hello"
str3 = "hello world"
str4 = "hello world" 

print(f"str1 is str2: {str1 is str2}") #  True (interned) for simple str
print(f"str3 is str4: {str3 is str4}") # May not be true for more complex str


# ---------- Example 22. FLOATING POINT ERRORS ---------------


# Issue 1: Simple arithmetic doesn't work as expected

print("1. Basic arithmetic problems:")
result = 0.1 + 0.2
print(f"0.1 + 0.2 = {result}")
print(f"Does 0.1 + 0.2 == 0.3? {result == 0.3}")
print(f"Actual result: {result:.17f}")
print(f"Expected: 0.30000000000000000")
print()

# Issue 2: Accumulation errors

print("2. Accumulation errors in loops:")
total = 0.0
for i in range(10):
    total += 0.1
print(f"Adding 0.1 ten times: {total}")
print(f"Does it equal 1.0? {total == 1.0}")
print(f"Actual result: {total:.17f}")
print()

# Issue 3: Precision loss with very different magnitudes

print("3. Precision loss with different magnitudes:")
large_num = 1e16
small_num = 1.0
result = large_num + small_num - large_num
print(f"(1e16 + 1.0) - 1e16 = {result}")
print(f"Expected: 1.0, but we got: {result}")
print()

# Solution using Decimal module

from decimal import Decimal

result_decimal = Decimal('0.1') + Decimal('0.2')

print(result_decimal)


'''The key takeaway for students is: never use == to compare floating point numbers directly! 
Always choose the appropriate method based on whether you need exact precision or can tolerate small differences.'''


##### ADDITIONAL REVIEW #####


# ---------- Arithmetic Operators ---------------


print(5+5)
print(5-6)
print(10/2)
print(5**2)

print(10//3)  # floor (integer) division what is happening here? Integer division is always rounded toward minus infinity
print(10%3)   # modulus or remainder what is happening here?

print(-9//5) # -2; floor division rounds down to the nearest integer. The exact result of -9 / 5 is -1.8. When you round -1.8 down to the nearest integer, you get -2
print(-9%5) 

# truncation is different. It rounds towards zero

int(1.75)
int(-1.75)

'''
In Python, the sign of the result in a modulus operation is the sign of the divisor (the number after the %). In this case, the divisor is 5, which is positive.

So, when you calculate -9 % 5, it means "what is left over after dividing -9 by 5 and rounding towards negative infinity".

The closest multiple of 5 that is less than -9 is -10. The difference between -9 and -10 is 1. You typically dont need to use "%" in your work but it's helpful to understand it;
'''

# what do you expect these to print?

print(9//0)
print(9%0)


# A basic calculator for geometry

height = 3
length = 4
area = height*length/2
hypotenuse = (height**2 + length**2)**0.5  # precendence and sqrt equivalent
print(f'\nThe hypotenuse of the right triangle is {hypotenuse}\n')
print(f'The area of the triangle is {area}\n.')

## Arithmetic operators on strings - concatenate with + operator

x = '20'
y = '30'
print(x+' ' +y)
print(x+y)
print(x*3 + y*2)

sam = 'That was a very big dog '
fred = 'with huge teeth'
print(f'Adding string variables sam + fred results in: {sam + fred}')

cat = 'tabby cat'  # how long is this string??

print(f'The length of the string "cat" is {len(cat)}')

#this will produce a type error 

print(x*y)

#this will produce a type error 

print(x*3 + y/2)



# Operator Precedence 

a = 6*3+7*4  # (6*3), then (7*4), then (18+28)
b = 5+3/4  #(3/4), then (5+0.75)
c = 5-2*3**4  #(3**4), (2*81), then (5-162)

print(f'Evaluating order: the value of a is {a}, the value of b is {b}, \
and the value of c is {c}\n')

# Exponents

a ** b  # power operation
pow(a, b) # this is another way to write an exponent

# ---------- Relational Operators ---------------

var1 = 5
var2 = 6
var3 = 5

print(
    f'var1: {var1}\n'
    f'var2: {var2}\n'
    f'var3: {var3}\n'
)

# Quick note on terminology!
# Relational operater: <=
# Boolean expression: var1 <= var2
# Boolean expressions CONTAIN relational operators!

print(f'Checking equivalence of var1 and var2: {var1 == var2}')
print(f'Checking whether var1 does NOT equal var2: {var1 != var2}')
print(f'Checking whether var1 is larger than var2: {var1 > var2}')
print(f'Checking whether var1 is smaller than var2: {var1 < var2}')
print(f'Checking whether var1 is equal to or greater than var2: {var1 >= var2}')
print(f'Checking whether var1 is equal to or greater than var3: {var1 >= var3}')
print(f'Checking whether var1 is equal to or smaller than var2: {var1 <= var2}')
print(f'Checking whether var1 is equal to or smaller than var3: {var1 <= var3}')

# evaluate for True or False

print(9 % 3 == 0)
print(9 % 2 == 0)


# Relational operators can act on single characters, used for sorting purposes

b1 = 'H'
b2 = 'h'
print(f'The ASCII value corresponding to "H" is: {ord(b1)}\n')
print(f'The ASCII value corresponding to "h" is: {ord(b2)}\n')

print(b1 > b2)


# ---------- Logical Operators ---------------

# Logical operators add additional logic for more complex expressions!

print(True & False) # True is equivalent to 1, False is equivalent to 0
print(True and False)

print(True or False) # or returns true if at least one of the operands is true
print(True | False)

True | False | False | False | True | False

True | (False & True)


var1 = 28
var2 = 34

print(var1 > var2 or var1 < 30)
print(var1 < var2 and var2 < 30)
print(var1 < var2 and not var2 < 30)
print(var1 < var2 and var1 < 30)

# Precendence for logical operators

age = 7
profession = 'student'

print(age >= 37 and profession == 'student' or age < 18)
print(age >= 37 and (profession == 'student' or age < 18))

# Try to predict the result of the following print statement without executing code

x = 10
y = 5
z = 30

print((((x <= 5 and 6 >= 10) or y > 5) and z <= 30) or not False or False) 

# Some additional boolean considerations

int(True)
int(False)

bool(1)
bool(-42)
bool(0)

not True
not False
True and True
False or True

# True and False are subclasses of integers

1 + True # upcasting -> a type conversion that goes from subclass to parent

False + 42 

7 - True


'''
Python 3 references - https://docs.python.org/3/reference
Perils of floating point - https://www.lahey.com/float.htm
    Aliasing - https://v4.software-carpentry.org/python/alias.html
Truth Tables - https://en.wikipedia.org/wiki/Truth_table
'''


# ---------- Aliasing and Mutability ---------------

'''
Mutable objects can be modified in place, internal state can be changed - lists, sets, dictionaries

Immutable objects cannot be modified in place - numbers(int, float, booleans), strings, tuples, frozen sets, etc

'''


# Aliasing - two name bindings that point to the same location in memory (immutable types)

a = 10
b = 10

print(id(a), id(b)) 

# Compare memory addresses with 'is' identity operator

a is b

# Mutability - Lists are mutable. 

a = [1,2,3]
b = [1,2,3]

print(id(a), id(b)) 

a is b, a is not b

# Side effects of mutability

a = [5,6,7]
b = a 

print(id(a), id(b)) # same location
print(a == b, a is b) 

b.append(7)

print(a)
print(id(a), id(b)) 
print(a == b, a is b)

# Note difference with the following

b = b.append(4)
print(a)
print(id(a), id(b)) 
print(a == b, a is b)


##### MORE ON PRIMITIVE DATA TYPES #####

'''
A digit is a single symbol used to represent numbers in a counting system.
In our everyday decimal system (base 10), the digits are: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

Other number systems use different digits:

Binary (base 2): only 0 and 1
Hexadecimal (base 16): 0-9 plus A, B, C, D, E, F
'''
'''
COMP 3005
Homework 7 - Strings & Sets

General Homework Guidelines: 
- Homework must be submitted in a .py file. Please do not submit .ipynb files.
- Homework should not use packages or functions that have not yet been discussed in class.
- Use comments to explain what your code is doing. 
- Use a consistent coding style. 
- Use descriptive variable names.
- Test your code regularly using a variety of different inputs. 
- Every function must include a docstring for documentation (see: 
   https://realpython.com/documenting-python-code/). This docstring should include:
     - 1 or 2 lines describing what the function does
     - input parameters, their types and what they are for
     - return data type and what it is
- All tests of your functions should be commented out in your final submission or
  encolosed with an if __name__ == '__main__' codeblock.
- All functions should use return statements to return a value, rather than
  printing some value, unless the instructions specifically say to print.
'''
#--------------------------------------------------------------------------#

###-----------------###
###-----Strings-----###
###-----------------###

# All functions must be able to handle edge cases like an empty string or list and 
# strings and lists with a single character.


# 1. Write a function, called check_palindrome, that takes a string as an argument and 
# determines if the string is a palindrome. The function should return True if it is
# a palindrome, False otherwise. 
# A palindrome is a string that is the same forward and backward like: level or noon.
# Make sure your function works on the string "rats live on no evil star"
# (10 points)

def check_palindrome(string):
  '''
  Checks if a string is a palindrome

  Parameters:
    string: a string to be checked

  Returns:
    boolean: True of False if the original string is a palindrome
  '''
  
  # edge cases
  if type(string) is not str:
    raise TypeError('Input must be a string.')
  if string == '' or len(string) <= 1:
    raise ValueError('Input error. String is empty or too short. Please try again.')

  # breaking down original string
  pure_chars = []

  for char in string:
    if char == ' ': 
      continue # skipping the spaces, only taking in characters
    else:
      pure_chars.append(char)
  og_string_no_space = ''.join(pure_chars) # original string with no space


  # breaking down reversed string

  reversed_chars = []

  for char in reversed(string):
    if char == ' ':
      continue # skipping spaces, only taking in characters
    else:
      reversed_chars.append(char)
  reversed_str_no_space = ''.join(reversed_chars) # reversed string with no space

  # comparing the processed strings with one another

  if reversed_str_no_space == og_string_no_space:
    return True
  return False


# 2. Create a function, called sort_strings, that takes a list of strings and sorts the list 
# based on the length of string from lower to higher. Cannot use built-in sorting functions
# (10 points)

def sort_strings(list_of_string):
  '''
  Sorts the list of strings based on the length of string from lower to higher

  Parameters:
    list_of_string: a list of strings to be sorted

  Returns:
    list: a sorted list of strings
  '''
  
  # edge cases
  if type(list_of_string) is not list:
    raise TypeError('Input must be a list.')
  if list_of_string == [] or len(list_of_string) <= 1:
    raise ValueError('Input error. List is empty or too short. Please try again.')
  

  # nested iteration
  n = len(list_of_string)

  for i in range(n-1):
    for j in range(n-1-i):
      if list_of_string[j] > list_of_string[j+1]:
        list_of_string[j], list_of_string[j+1] = list_of_string[j+1], list_of_string[j]
  
  return list_of_string


# 3. Write a function, called mixed_string, that takes a word string and computes a list of all 
# words generated by a single swap of letters in the word. For example ‘swap’ should return 
# [‘wsap’, ‘sawp’, swpa’] (notice that letters are only swapped with their 
# immediate neighbors only, i.e. you don’t have ‘waps’)(10 points)

def mixed_string(word):
  '''
  Computes a list of all words generated by a single swap of letters with 
  their immediate neighbor letters within the word

  Parameters:
    word: a string to be computed

  Returns:
    list: a list of processed strings
  '''

  # edge cases
  if type(word) is not str:
    raise TypeError('Input must be a string.')
  if word == '' or len(word) <= 1:
    raise ValueError('Input error. String is empty or too short. Please try again.')

  # breaking down word into a list
  chars = []
  for char in word:
    chars.append(char)
  
  # define length n of the list, create an empty list to store new mixed strings
  n = len(chars) 
  mixed_str = []
  
  for i in range(n-1):
    chars[i], chars[i+1] = chars[i+1], chars[i] # swapping letter at index i and its immediate neighbor i+1
    new_word = ''.join(chars) # join the new string to make a word
    mixed_str.append(new_word) # add it to the new mixed_str list
    chars[i+1], chars[i] = chars[i], chars[i+1] # swap them right back to orignial index before moving on
  return mixed_str


# 4. Write a function, called reverse_phrase, that takes a string of words and returns the 
# string with the words in reverse order. You cannot use any library methods or functions 
# like .split(). For example if the sentence is: “I love python”, then the function returns: “python love 
# I” (10 points)

def reverse_phrase(str_of_words):
  '''
  Reverses the order of the words in the string given

  Parameters:
    str_of_words: a string that contains many words

  Returns:
    string: a string of words with said words in reversed order
  '''
  # edge cases
  if type(str_of_words) is not str:
    raise TypeError('Input must be a string.')
  if str_of_words == '' or len(str_of_words) <= 1:
    raise ValueError('Input error. String is empty or too short. Please try again.')  

  word = '' # empty string to store filted letters
  word_sep = [] # empty list to store completed words
  n = len(str_of_words) # length of list to run loop

  for i in range(n):
    if str_of_words[i] != ' ' and i != n-1: # if letter is NOT space or if it's NOT last iteration
      word += str_of_words[i] # update word by add looped letter

    else: 
      if i == n-1: # when loop at LAST iternation
        word += str_of_words[n-1] # include the last letter as well
      word_sep.append(word) # otherwise, append completed word to list
      word = '' # reset container to empty to filter the next word

  return ' '.join(word_sep[::-1]) # join the words with space ' ' in REVERSED order


# 5. Write a function, called unique_letters, that takes a string as an argument and returns 
# a new string with no duplicated letters. 
# For example if the word is: “application” then the function returns “aplicton”
# (10 points)

def unique_letters(string):
  '''
  Returns a new string without duplicated letters

  Parameters:
    string: a string to loop through and find duplicated letters

  Returns:
    string: new string with no duplicated letters
  '''
  # edge cases
  if type(string) is not str:
    raise TypeError('Input must be a string.')
  if string == '' or len(string) <= 1:
    raise ValueError('Input error. String is empty or too short. Please try again.')
  
  chars = []
  new_str = ''

  # breaking string down into a list of letters
  for char in string:
    chars.append(char) 

  n = len(chars) # length of list to loop through
  new_chars = [] # new list to store unique letters

  # loop through the list of original letters
  for i in chars: 
    if i not in new_chars: # if it's unique, add it to the new list
      new_chars.append(i)

  return ''.join(new_chars) # join the unique letters and return


###--------------###
###-----Sets-----###
###--------------###

# 6. Create a function, called set_comp, that uses Python set comprehension to generate a 
# set of pair tuples consisting of all of the integers between 1 and 10,000 and the square 
# of that number but only if the square is divisible by 3 and return that set. 
# For example (3, 9) would be in the set since 3^2 is 9 and 9 is divisible by 3.
# You should have 3333 tuples in your set.
# (10 points)

def set_comp():
  '''
  Uses set comprehension to generate a set of pair tuples, consisting all integers between 1 and 10,000
  and the square of that number, but only if that square is divisible by 3

  Parameters:
    none

  Returns:
    a set of tuples: 3333 tuples in said set that satify the aforementioned conditions
  '''
  
  # returns tuples for x in given range IF x^2 is divisible by 3
  return {(x, x**2) for x in range(1, 10000) if x**2 % 3 == 0}


# 7. Write a function, called min_max_set, that takes a set of numbers and returns the 
# minimum and maximum value in the set as a tuple. Cannot use the built-in functions 
# min()/max(). Hint: You may want to use math.inf and -math.inf
# (10 points)

import math
def min_max_set(set_of_num):
  '''
  Returns min and max values of a set in a tuple

  Parameters:
    set_of_num: a set of numbers

  Returns:
   tuple: a tuple containing min and max values of said set
  '''
  # edge cases
  if type(set_of_num) is not set:
    raise TypeError('Input must be a set.')
  if set_of_num == set() or len(set_of_num) <= 1:
    raise ValueError('Input error. Set is empty or too short. Please try again.')

  max_val = -math.inf # set max value, any number would be greater than -inf
  min_val = math.inf # set min value, any number would be less than +inf

  for i in set_of_num: # iterate through the set, if it's greater than previous max, it becomes the new max
    if i > max_val:
      max_val = i

  for j in set_of_num: # interate through the set, if it's less than previous min, it becomes the new min
    if j < min_val:
      min_val = j

  return min_val, max_val # returns a tuple



# 8. Write a function, unique_elems, that given a list of values, determines if all elements 
# are unique (no repeated values). If elements are unique return True and False otherwise. 
# You must use a set to perform this task.
# (10 points)

def unique_elems(list_of_val):
  '''
  Determines if a list of values only contains unique values, if yes, return True, and False otherwise

  Parameters:
    list_of_val: a list of values to be compared and determined uniqueness

  Returns:
    boolean: True if all values are unique, False otherwise
  '''
  # edge cases
  if type(list_of_val) is not list:
    raise TypeError('Input must be a list.')
  if list_of_val == []:
    raise ValueError('Input error. List is empty or too short. Please try again.')  
  
  filtered_dup = set(list_of_val) # make it a set (only unique values)

  # compare length of the set & the list
  # same length = both only have unique values
  # different length = some duplicates got filtered out, hence False

  return len(filtered_dup) == len(list_of_val)

# 9. Write a function, called distinct_elems, that takes two sets, A and B, and returns a new 
# frozen set containing elements that are in either A or B but NOT in the intersection of A 
# and B. 
# (10 points)
 
def distinct_elems(setA, setB):
  '''
  Returns only elements that are either in A or B but NOT the mutual elements (intersection of A and B)

  Parameters:
    setA, setB: two sets to be compared and filterd

  Returns:
    frozenset: containing only elements in A or B but NOT A and B
  '''
  # edge cases
  if type(setA) is not set or type(setB) is not set:
    raise TypeError('Input must be a set.')
  if setA == set() or setB == set():
    raise ValueError('Input error. Set is empty or too short. Please try again.')
  
  # returns frozenset of the union - intersection of setA and setB
  return frozenset(setA.union(setB) - setA.intersection(setB))


# 10. Write a function, called adds_to_K, that given an integer k and a list of n unordered 
# integers A, determines if there is a distinct pair of integers in A that add up to k. 
# Return True if a pair of integers add up to k, return False other.
# You must perform this task using sets. 
# (10 points)

def adds_to_K(k, A):
  '''
  Returns True if there is a distinct pair in A that adds up to k, False otherwise

  Parameters:
    k: an integer
    A: a list of unordered integers

  Returns:
    boolean: Returns True if there is a distinct pair in A that adds up to k, False otherwise
  ''' 

  # edge cases
  if type(k) is not int:
    raise TypeError('k must be an integer.')
  if type(A) is not list:
    raise TypeError('A must be a list.')
  if A == [] or len(A) <= 1:
    raise ValueError('Input error. List is empty or too short. Please try again.')

  filtered_dup = set(A) # filter out duplicates
  filtered_list = list(filtered_dup) # back to list for easy looping and indexing
  list_of_pairs = []

  for i in filtered_list:
    for j in filtered_list:
      if i != j:
        list_of_pairs.append([i,j]) # creating distinct pairs

  for pair in list_of_pairs: # looping through the list of pairs
    if pair[0] + pair[1] == k: # if first in pair + second in pair = k
      return True 
  return False


#--------------------------------------------------------------------------------------------------#

if __name__ == '__main__':
  pass
# # test 1
# print(check_palindrome('rats live on no evil star'))
# edge cases 1
# print(check_palindrome(''))
# print(check_palindrome([1,2,3]))

# # test 2
# print(sort_strings([5,2,4,1, 18, 45, 1100, 12, 0, -1, -45]))
# edge cases 2
# print(sort_strings([]))
# print(sort_strings([1]))
# print(sort_strings(1))

# # test 3
# print(mixed_string('swap'))
# print(mixed_string('pitch'))
# print(mixed_string('soccer'))
# edge cases 3
# print(mixed_string(''))
# print(mixed_string('a'))
# print(mixed_string(8.9))

# # test 4
# print(reverse_phrase('seglass ni tonday'))
# print(reverse_phrase('I love Python'))
# edge cases 4
# print(reverse_phrase(''))
# print(reverse_phrase('a'))
# print(reverse_phrase((5,6,7)))

# # test 5
# print(unique_letters('application'))
# edge cases 5
# print(unique_letters(''))
# print(unique_letters('a'))
# print(unique_letters([1,2,3]))

# # test 6
# print(set_comp())

# # test 7
# print (min_max_set({3, 367, 4, 45, 0, -5, 12, 66, -21}))
# edge cases 7
# print(min_max_set(set()))
# print(min_max_set({1,}))
# print(min_max_set([-9,12,3]))

# # test 8
# print(unique_elems(['dolphin', 'sunset', 1, 5, 'sunset', 28]))
# print(unique_elems([1, 2.4, 'chaos', 4, 1001, 'entropy']))
# edge cases 8
# print(unique_elems([]))
# print(unique_elems({2,2,3}))


# # test 9
# # noice fact: return excludes True, because hash(True) = 1
# same for False as hash(False) = 0
# print(distinct_elems({1, 2, 3, 'armor', 4.5}, {1, 2, 3, True, (-90, 'east')}))

# edge cases 9
# print(distinct_elems({1,2,3}, [4,5,6]))
# print(distinct_elems('coords', {-9,13,'pineapple'}))
# print(distinct_elems(set(), {1,4,5}))
# print(distinct_elems({3,4,5}, set()))
# print(distinct_elems(set(), set()))

# # test 10
# print(adds_to_K(23, [19, 4, 7, 7, -8]))
# print(adds_to_K(55, [44, 10, 0, 15, 4, 0]))
# edge cases 10
# print(adds_to_K('ten', [5,5,9]))
# print(adds_to_K(10, {12,3,4}))
# print(adds_to_K(10, []))
# print(adds_to_K(10, [10]))


















